import os
import ConfigParser
import json
import syslog
from jwcrypto import jwk, jwt

from shared import GlobalConfig, GlobalTime, opaque_identifier, opaque_integer, opaque_mix, specific_cookie
from keypair import ConstantinaKeypair

syslog.openlog(ident='constantina.preferences')


class ConstantinaPreferences:
    """
    Set preferences for an individual user.

    Constantina's strategy for this is to leave all settings off of the server,
    as well as avoiding any settings that could be used for tracking users
    by their real-world details. So none of these settings have any concept of
    a "user profile".

    Indeed, the settings are all stored in a user cookie, which is then signed
    and encrypted using per-account keys stored on the server. This way, the
    cookie's purpose may remain opaque on the client, and the settings cannot be
    changed or sniffed on the server without an active session from the user
    actively occuring.
    """
    def __init__(self, username, mode, **kwargs):
        self.username = username
        self.__read_config()
        self.__default_preferences()

        if mode == "set":
            pass
        if mode == "cookie":
            # Cookie name things go here
            pass

    def __read_config(self):
        """Necessary config files for setting preferences."""
        self.config_file = "preferences.ini"
        self.config_root = GlobalConfig.get('paths', 'config_root')
        self.config_path = self.config_root + "/" + self.config_file
        self.zoo = ConfigParser.SafeConfigParser()
        self.zoo.read(self.config_root + "/zoo.ini")
        self.preferences = ConfigParser.SafeConfigParser()
        self.preferences.read(self.config_path)
        self.shadow = ConfigParser.SafeConfigParser()
        self.shadow.read(self.config_root + "/shadow.ini")

    def __default_preferences(self):
        """
        Set all the default preference claims a user gets:
            thm: the user's chosen theme
            top: the default forum topic for this user, if none else chosen
            gro: thread expansion strategy for the Zoo forum
                0=expand all threads
                N>0: expand last N*10 threads
            rev: user's configured time for editing a thread.
        Initialize the available signing and encryption keys to "None".
        Based on the username, set the expected cookie name and id.
        TODO: refactor auth settings to use similar default strategy.
        """
        self.thm = GlobalConfig.get("themes", "default")
        self.top = "general"
        self.gro = 0
        self.rev = self.zoo.get('zoo', 'edit_window')

        self.instance_id = GlobalConfig.get("server", "instance_id")
        self.preference_id = self.preferences.get(self.username, "preference_id")
        self.cookie_id = self.create_cookie_id(self.instance_id, self.preference_id)
        self.cookie_name = ("__Secure-" +
                            GlobalConfig.get('server', 'hostname') + "-" +
                            self.cookie_id)

        # Given the preference_id, create/load the keypair
        self.keypair = ConstantinaKeypair(self.config_file, self.cookie_id)

    def set_preference_claims(self, pref_dict):
        """
        Given a settings token was read correctly, sanity check its settings here.
        TODO: value-domain checks etc.
        """
        self.thm = pref_dict['thm']
        self.top = pref_dict['top']
        self.gro = pref_dict['gro']
        self.rev = pref_dict['rev']
    
    def set_user_preference(self, username, preference_id):
        """
        Create new keys and preference ID for this user, regardless of what
        already exists in the preferences file. Don't track when settings keys
        were made or regenerated, as this info isn't as crucial as session keys.

        The preference ID is generated by constantina_configure when an
        account is made, but it calls here to set it.
        """
        self.preferences.set(username, "preference_id", preference_id)

    def get_cookie_preference_id(self, instance_id, cookie_id):
        """
        Whichever preference-id XORs the cookie-id into the instance-id, that
        is the correct key for dealing with this cookie.
        """
        instance_int = opaque_integer(instance_id)
        cookie_int = opaque_integer(cookie_id)
        return opaque_identifier(instance_int ^ cookie_int)

    def create_cookie_id(self, instance_id, preference_id):
        """
        XOR the instance_id and preference_id binary representations together, and
        and then output the BASE62 minus similar characters result, for use as the
        cookie identifier. This ties setting cookies to a specific site instance.
        """
        return opaque_mix(instance_id, preference_id)

    def read_cookie_preferences(self, cookie):
        """
        Given a cookie, read the preferences so the settings screen can be populated.
        If the cookie doesn't exist, return False.
        """
        preference_id = self.get_cookie_preference_id(self.instance_id, self.cookie_id)
        # TODO: use keys to decrypt cookie and read deets from preferences.

    def write_cookie_preferences(self, cookie_id):
        """Set new preferences, and then write a new cookie."""
        pass

